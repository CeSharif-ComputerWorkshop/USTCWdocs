

# سامانه‌های کنترل نسخه (VCS)

Version Control System یا VCS یکی از مهم‌ترین سیستم‌های مورد استفاده در دنیای برنامه‌نویسان امروز است. با یک مثال ساده، یکی از ویژگی های مهم این سیستم را بررسی می‌کنیم. فرض کنید یک فایل متنی را ایجاد و چندین بار آن را ویرایش کرده‌اید. در ویرایش پنجم به این نتیجه می‌رسید که ویرایش اول شما بهتر بوده و قصد بازگشت به نسخه‌ای را دارید که در ویرایش اول ایجاد شده‌است. VCS این امکان را به شما می‌دهد که بی‌نهایت بار اشتباه کنید و بتوانید اشتباهات خود را جبران کنید. به وسیلهٔ VCS ها، می‌توانید نسخه‌های متفاوتی از فایل‌های پروژه را نگهداری کرد و در صورت وقوع اشتباه، آن را تصحیح کرد. البته این یکی از چندین کاربرد‌ برای VCS ها است.

VCS ها تغییرات و ویرایش‌های ما را ذخیره‌سازی کرده و به هنگام خطا و در صورت نیاز می‌توانند نسخه های قبلی را بازیابی کنند. همچنین VCS ها با فراهم کردن امکانات زیادی مثل قابلیت پیگیری تغییرات اعمالی هر یک از برنامه‌نویسان، ساخت شاخه‌های مختلف از پروژه، جلوگیری از تداخل کدهای برنامه نویسان و …. فرآیند توسعه پروژه‌ها به صورت گروهی را ساده‌تر می‌سازند. اساس کارکرد تمامی VCS ها بر روی ثبت و ذخیره‌سازی تاریخچهٔ تغییرات فایل‌هایی است که ما آنها را تغییر می‌دهیم. 

برخی از ویژگی‌های مهم این سیستم‌ها عبارتند از:

1. **قابلیت بازگشت به نسخه‌های مختلف از محتویات فایل‌ها**
2. **کاهش ریسک از دست رفتن فایل در اثر اشتباه** 
3. **مقایسه نسخه‌های مختلف یک فایل و بررسی تغییرات** 
4. **پشتیبان‌گیری از انواع فایل‌ها نظیر کدهای یک برنامه کامپیوتری و یا فایل های صوتی و تصویری** 

------



## انواع VCS 

VCS ها به سه دستهٔ **محلی**، **متمرکز** و **توزیع‌شده** تقسیم می‌شوند. در ادامه هر کدام از دسته‌ها بررسی خواهدشد.

![1](../imgs/git/1.png)

*تصویر ۱ - انواع سامانه‌های کنترل نسخه*



### VCS محلی 

ساده‌ترین کاری که یک کاربر می‌تواند برای کنترل نسخ پروژه خود انجام‌دهد، کپی کردن فایل‌ها داخل یک پوشه جدا (و اگر هوشمندانه باشد، با ثبت ساعت و تاریخ آن لحظه به عنوان نام پوشه) است. علی‌رغم راحتی و سادگی، اینکار مستعد خطا است؛ مثلا کاربر به سادگی می‌تواند مبدا و مقصد عملیات کپی را اشتباه کند و همه چیز خراب شود! یا حتی تغییرات در فایل‌های قدیمی‌تری انجام شود که تغییرات جدیدتر را در خود ندارد!

برای حل این مشکل، برنامه‌نویسان از مدت‌ها پیش سیستم‌های مدیریت نسخه‌ای را توسعه دادند که از یک پایگاه داده ساده برای ثبت تغییرات در فایل‌ها بهره می‌بردند. 

![1](../imgs/git/2.jpg)

*تصویر ۲ - شمای سامانه کنترل نسخه محلی*



یکی از معروف‌ترین ابزارهای VCS به نام RCS (Revision Control System) است که همچنان بر روی بسیاری از کامپیوترها (عمدتا لینوکسی) یافت می‌شود. RCS با نگهداری مجموعه‌ای از وصله‌ها (Patch؛ تغییرات بین دو نسخه متوالی از فایل) در قالب یک فرمت مشخص بر روی دیسک کار می‌کند. پایگاه داده RCS تنها در اختیار کاربر محلی کامپیوتر قرار دارد؛ بنابراین افراد بیرون از ناحیهٔ محلی توانایی استفاده از نسخه‌های این نوع از VCS را ندارند.

از نقاط ضعف این مدل از VCS ها می‌توان به عدم امکان مدیریت پروژه‌های گروهی و همچنین نقطه تکی شکست در آنها اشاره کرد.

<div class="meta info">
<p>
به این معنا است که منابع مورد استفاده در یک نقطه تجمیع شده است و در صورتی بوجود آمدن خرابی در آن نقطه، منابع با خطر خرابی یا از بین رفتن مواجه خواهند بود.
</p>
</div>



### VCS متمرکز 

(غیر از نیاز مدیریت فردی پروژه‌ها) نیازی دیگری که کاربران با آن مواجه بودند، همکاری با سایر توسعه‌دهندگان (افرادی که به سیستم محلی کاربر دسترسی نداشتند) بود. برای رفع این نیاز، سامانه‌های کنترل نسخه متمرکز ارائه شدند. این سامانه‌ها از یک سرور که حاوی تمام نسخه‌های فایل‌ها استفاده می‌کند. هر یک از کاربرانی که بر روی یک پروژهٔ مشترک فعالیت می‌کنند، می‌توانند مستقلا با سرور در ارتباط باشند (به صورت ارتباط Client/Server)، تغییرات جدید را دریافت و یا تغییرات خودشان در آن ثبت کنند. برای مثال، در تصویر زیر می‌بینیم که کاربر A و کاربر B به صورت مستقل به سرور VCS مرکزی متصل هستند و عملیات مورد نیاز خود را انجام می‌دهند. برای سال‌های متمادی، نوع متمرکز به عنوان نوع استاندارد VCSها شناخته می‌شدند.

![1](../imgs/git/5.jpg)

*تصویر ۳ - شمای سامانه کنترل نسخه متمرکز*



با این حال، VCSهای متمرکز نیز خالی از مشکل نیستند. واضح‌ترین مشکل آنها، بوجود آمدن یک نقطه شکست (Single point of failure) به واسطه متمرکز بودن معماری آنها است؛ اگر سرور برای چند ساعت در دسترس نباشد (مثلا با هدف تعمیرات، بروزرسانی یا حتی خرابی سرور) هیچ کاربری نمی‌تواند نسخه‌های جدید از فایل‌هایش را ذخیره کند. یا حتی بدتر از آن، اگر دیسک سخت سرور خراب شود، تقریبا همه چیز از بین می‌رود!

در این نوع VCS‌ها، تمام داده‌ها بر روی **تنها** یک سرور مرکزی ذخیره می‌شوند. یعنی اگر برنامه‌نویسان بخواهند تغییراتی در پروژه ایجاد کنند، باید به سرور مرکزی متصل باشند؛ در غیر اینصورت نمی‌توانند به اطلاعات پروژه دست پیدا کنند.

به طور خلاصه، ویژگی‌های VCS متمرکز عبارتند از:

1. دسترسی چندین کاربر به یک منبع 
2. امکان مدیریت متمرکز بر روی مجوز های دسترسی 

همچنین، برخی از نمونه‌های VCS متمرکز عبارتند از: 

1. CVS 
2. Perforce 
3. Subversion 



### VCS توزیع‌شده

 در یک VCS توزیع‌شده، کاربران نه تنها آخرین تغییرات اعمال‌شده بر فایل‌ها را از سرور دریافت می‌کنند، بلکه یک نسخه کامل از مخزن (=محلی که مجموعه فایل‌های حاوی نسخه‌های مختلف از یک پروژه در آن قرار داد) به همراه سابقه آن را نیز در سمت خود می‌سازند. بنابراین، در صورت وقوع خرابی در سرور، هر کدام از مخازن ساخته شده سمت کاربران می‌تواند به عنوان پشتیبان در نظر گرفته شده و بازیابی اطلاعات در سرور از طریق آن انجام شود (حتی هر کاربر خودش می‌تواند در نقش سرور برای باقی کاربران عمل کند). به عبارت دیگر، هر کاربری که از VCS توزیع‌شده استفاده می‌کند، یک نسخه پشتیبان کامل از تمام داده‌ها را در اختیار دارد. همچنین در صورتی که سرور اصلی در دسترس نباشد، اعضای گروه می‌توانند تغییرات را در سیستم خودشان اعمال کرده و در زمانی که ارتباط دوباره برقرار شد آن را با سرور اصلی هنگام‌سازی کنند.

![1](../imgs/git/6.jpg)

*تصویر ۳ - شمای سامانه کنترل نسخه توزیع‌شده*



به علاوه، بسیاری از VCS های توزیع‌شده، قابلیت پشتیبانی از چندین مخزن از راه دور را دارند. به این صورت که کاربر می‌تواند بر روی توسعه یک پروژهٔ واحد با تیم‌های مختلفی که آدرس مخزن سرورشان با یکدیگر متفاوت است، همکاری کند.(تعریف مخزن و ویژگی‌های آن در ادامه‌ی طرح درس توضیح داده‌شده است)


یکی از مهمترین و پرکاربردترین سیستم های VCS توزیع شده، GIT می باشد. نمونه‌های دیگر از VCS توزیع‌شده عبارتند از:

1. Bazaar 

2. Mercurial

3. Darcs 

در تصویر زیر میتوان تاریخچهٔ ظهور VCS های توزیع‌شده را مشاهده نمود.

![1](../imgs/git/8.jpg)

*تصویر ۴ - خط زمانی ظهور VCSهای توزیع‌شده*



در ادامه به بررسی پرکاربردترین VCS موجود یعنی **GIT** می‌پردازیم. 

------



## گیت GIT 

همانطور که گفته شد، گیت یک سیستم کنترل نسخه است که به صورت توزیع‌شده سازماندهی می‌شود. گیت یکی از ابزار های مهم در زندگی برنامه‌نویسان است و هر برنامه‌نویسی باید آشنایی کاملی با این ابزار مهم داشته باشد.

توسعهٔ گیت زمانی آغاز شد که بسیاری از توسعه‌دهندگان لینوکس، در استفاده از بیت کیپر، یک سیستم مدیریت کد می‌باشد که قبلاً برای توسعه هستهٔ لینوکس استفاده می‌شد، امتناع ورزیدند. 

در درختواره زیر یک شمای کلی‌ از تاریخچهٔ گیت را مشاهده می‌کنید:‌

![1](../imgs/git/9.jpg)

*تصویر ۵ - درختوارهٔ تاریخچه توسعه لینوکس*



گیت برای هماهنگ کردن وظایف میان اشخاص مختلفی که روی یک پروژه کار می‌کنند، بسیار مفید است. می‌توانید از گیت برای نوشتن یک مقاله استفاده کنید، یا وقتی که می‌خواهید تغییراتِ اعمال شده را، در یک فایل هنری یا طراحی، پیگیری کنید.

همانطور که در بخش قبل مورد بررسی قرار گرفت، گیت تنها سیستم کنترل نسخه موجود نیست، اما معروف‌ترین آنهاست. بسیاری از برنامه‌نویسان به صورت روزانه از گیت استفاده می‌کنند و تسلط روی آن می‌تواند تأثیر خوبی روی رزومه‌ی کاری‌تان داشته باشد.

اهداف مهم توسعه گیت عبارتند از:

1. **سرعت**
2. **طراحی ساده**
3. **پشتیبانی از توسعه غیر خطی**: یعنی چندین شاخه از یک پروژه را بتوان به صورت موازی پیش برد
4. **توزیع شدگی کامل**
5. **توانایی مدیریت پروژه های بزرگ** (‌مانند کرنل سیستم عامل لینوکس)



## نگهداری داده‌ها در گیت

مهمترین تفاوت بین GIT و سایر VCSها (مانند SVN)، دیدگاه آن نسبت به ذخیره‌سازی داده‌ها است شده است. در اکثر VCSها، اطلاعات به شکل لیستی از تغییرات فایل-محور ذخیره می‌شود. در واقع، این ابزارها به اطلاعات به چشم مجموعه‌ای از فایل‌ها و تغییراتی نگاه می‌کنند که در گذر زمان در فایل‌های اولیه اتفاق می‌افتند. به این روش کنترل نسخه اصطلاحا **تغییر-محور** گفته می‌شود.

تصویر زیر یک سناریوی ساده از این مدل ذخیره‌سازی را شرح می‌دهد؛ در نسخه ۱، ۳ فایل A، B و C وجود داشته‌اند. بعد از مدتی، فایل‌ها A و C دچار تغییر شده و تغییرات رقم خورده در این دو فایل در نسخه ۲ ذخیره می‌شوند. از آنجایی که فایل B تا زمان ثبت نسخه ۲ تغییری نداشته است، اطلاعات جدیدی از آن در نسخه ۲ اضافه نمی‌شود.  به همین منوال، عملیات ثبت نسخ جدید در آینده نیز ادامه پیدا می‌کند.



![1](../imgs/git/10.jpg)

*تصویر ۶ - ذخیره‌سازی اطلاعات به شکل تغییرات نسبت به نسخه پایه هر فایل*



بر خلاف VCSهای مبتنی بر دیدگاه تغییر-محور، GIT به اطلاعات به چشم جریانی از لحظه‌نگارهای (Snapshot) یک فایل‌سیستم مینیاتوری نگاه می‌کند. هر زمان که آماده ایجاد نسخه جدید می‌شوید و حالت فعلی پروژه خود را ذخیره می‌کنید، GIT در آن لحظه یک تصویر (=لحظه‌نگار) از تمام فایل‌های شما ثبت کرده و اشاره‌گری به آن را ذخیره می‌کند. برای کارایی بیشتر، فایل‌هایی که تغییری نداشته‌اند، در لحظه‌نگار جدید ثبت نمی‌شوند و تنها ارجاعاتی به آنها (در آخرین نسخه تغییر یافته) نگهداری می‌شود.

در تصویر زیر، می‌توانیم سناریوی مبتنی بر مدل ذخیره‌سازی اطلاعات در GIT را مشاهده کنیم؛ در نسخه ۱، تمام فایل‌های پروژه ثبت می‌شوند. در نسخه ۲، تنها فایل‌های A و C تغییر یافته است؛ لذا در لحظه‌نگار مربوط به نسخه ۲، کل فایل‌های A و C و لینک به فایل‌ B در نسخه ۱، در نظر گرفته خواهند شد. در نسخه ۳، تنها فایل C تغییر یافته است؛ لذا کل فایل C به همراه لینک‌های فایل B در نسخه ۱ و فایل B در نسخه ۲ در لحظه‌نگار مربوطه ذخیره خواهند شد.

![1](../imgs/git/11.jpg)

*تصویر ۷ - ذخیره‌سازی اطلاعات به شکل جریانی از لحظه‌نگارها در طول انجام پروژه*

------



## نصب گیت

ابزار گیت (تقریبا) در هر سیستم عاملی قابل نصب است. در ادامه، راهنمای نصب مربوط به دو سیستم عامل ویندوز و توزیع‌ لینوکسی Ubuntu آورده شده است.



### طریقه نصب در ویندوز 

برای نصب گیت در سیستم عامل ویندوز باید در از طریق سایت رسمی [گیت](https://git-scm.com/download/win) نسخه مربوط به سیستم عامل خود را دانلود و به شکل زیر آن را نصب کنید. 

 ![1](../imgs/git/12.jpg)

![1](../imgs/git/13.jpg)

![1](../imgs/git/14.jpg)

*تصویر ۸ - مراحل نصب گیت در سیستم عامل ویندوز*



پس از اتمام مراحل نصب به شکل بالا Git Bash نیز در ویندوز به صورت خودکار نصب شده است. با استفاده از Git bash می‌توان دستورات مهم لینوکسی را در محیط سیستم عامل ویندوز اجرا کرد .(تصویر زیر)

<p align="center">
  <img src="../imgs/git/15.jpg">
</p>
*تصویر ۹ - بررسی نسخه گیت نصب‌شده*



### طریقه نصب در Ubuntu

در سیستم عامل لینوکس و در نسخه ی Ubuntu با استفاده از دستور زیر می‌توان گیت را نصب کرد :‌

```bash
sudo apt-get update 
sudo apt-get install git 
```

در سایر توزیع‌های لینوکسی نیز بسته به مدیریت پکیج آن، می‌توان اقدام به نصب گیت کرد. برای مثال، در نسخه‌های redhat می‌توان با اجرای دستور زیر، گیت را نصب کرد. 

```bash
sudo yum install git 
```

------



## اصطلاحات مهم
قبل از آغاز کار با گیت و بررسی امکانات آن به صورت عملی، می‌بایست با اصطلاحات حیاتی و مهم آن آشنایی پیدا کنیم. تعدادی از مهمترین این اصطلاحات در ادامه آورده شده است.



### مخزن یا Repository 

مخزن در بردارنده ی سابقه ی کلی پروژه ی شماست. تمام تغییرات شما در یک پروژه بر روی فایل ها در یک مخزن قابل مشاهده است.

<p align="center">
  <img src="../imgs/git/16.jpg">
</p>


*تصویر ۱۰ - مخزن*



دو نوع مخزن داریم:

1. **محلی**: این نوع مخزن روی ماشین و کامپیوتر شما ذخیره می‌شود و می‌توان به صورت مستقیم به آن دسترسی داشت. 
2. **از راه دور** (ریموت): این نوع از مخزن ها در واقع یک سرور هستند که افراد مختلف می‌توانند به آن متصل شده و تغییرات را دریافت کنند.



### اصلاح(Revision)  

در گیت تغییرات نسبت به نسخه های قبلی ذخیره می‌شود و هر تغییر تحت عنوان یک اصلاح یا Revision ذخیره می‌شود. Revision ها یک نویسنده ی مشخص دارند و علاوه بر این حاوی پیامی است که توضیحات مربوط به تغییرات این نسخه است که توسط نویسنده بیان شده است.

<p align="center">
  <img src="../imgs/git/17.jpg">
</p>


*تصویر ۱۱ - اصلاح*



### برچسب (Tag)

پس از چندین اصلاح ممکن است به یک اصلاح خاص برسیم (مثلا یک نسخه از پروژه تولید شود که بخواهیم آن را به شکلی متمایز کنیم) که می‌توان آن را به وسیله یک برچسب علامت‌گذاری کرد.

![1](../imgs/git/18.jpg)

*تصویر ۱۲ - برچسب*



### شاخه(Branch)  

برای فهم بهتر مفهوم شاخه، سناریوی زیر را در نظر بگیرید؛ فرض کنید شما و دوست برنامه‌نویس‌تان قصد دارید روی یک پروژه کار کنید و قسمت‌های مختلف را بین خود تقسیم می‌کنید. برای این که شما دو نفر به صورت موازی بتوانید وظایف مشخص خود را پیش ببرید هر کدام یک شاخه ایجاد کرده و تغییرات را روی شاخهٔ مربوط به خودتان انجام می‌دهید. استفاده از شاخه در گیت خصوصا در پروژه‌هایی که به **صورت گروهی** انجام می‌گیرد، بسیار ضروریست.

برای مثال در تصویر پایین، دو شاخه وجود دارد؛ یکی شاخهٔ اصلی و دیگری شاخه‌ای که از اصلاح `v1.0` از شاخهٔ اصلی انشعاب گرفته شده است.

![1](../imgs/git/19.jpg)

*تصویر ۱۳ - شاخه*



### ایجاد تغییر در پروژه و اعمال آن 

فرض کنید در یک پروژه (که تحت گیت مدیریت می‌شود) وظایفی به شما در مورد توسعه پروژه محول شده است:

![1](../imgs/git/20.jpg)

*تصویر ۱۴ - شمای شاخه اصلی*

ابتدا باید یک کپی از آخرین نسخهٔ پروژه را دریافت کنید (در این سناریو فرض کرده‌ایم که آخرین نسخه از شاخهٔ `master` دریافت شده است). به این عمل، Checkout گفته می‌شود که در نتیجه آن، شما یک نسخه (Working Copy) از پروژه را در پوشه مد نظر خود (Working tree) ایجاد می‌کنید:

![1](../imgs/git/22.jpg)

*تصویر ۱۵ - دریافت آخرین نسخه پروژه*

بعد از دریافت پروژه، می‌توانیم تغییرات را بر روی فایل‌های آن اعمال کنیم:

![1](../imgs/git/23.jpg)

*تصویر ۱۶ - اعمال تغییرات بر روی فایل‌های پروژه*

پس از اعمال تغییرات، می‌بایست آنها را به شکل یک اصلاح جدید در مخزن ذخیره کنیم. به این کار ثبت یا اصطلاحا کامیت (Commit) گفته می‌شود.

![1](../imgs/git/24.jpg)

*تصویر ۱۷ - اعمال تغییرات روی مخزن و ثبت آنها*



از دیدگاه گیت، فایل های پروژه (موجود در Working Directory) می‌توانند یکی از ۴ حالات زیر را داشته باشند:

- **Untracked**: داخل Working Directory (پوشه پروژه) هستند ولی توسط گیت رصد نمی‌شوند.
- **Unmodified**: توسط گیت رصد می‌شوند و از کامیت قبلی تاکنون تغییری نداشته‌اند.
- **Modified**: توسط گیت رصد می‌شوند، ولی برای حضور در کامیت بعدی انتخاب نشده‌اند.
- **Staged**: آماده ی حضور در کامیت بعدی هستند.

![1](../imgs/git/26.jpg)

*تصویر ۱۸ - حالات مربوط به فایل‌های پروژه*



به ناحیه‌ای که فایل‌های دارای حالت Staged در آن قرار دارند، اصطلاحا Staging Area یا Index Area نیز گفته می‌شود.


## ساخت مخزن
پس از این که مفهوم مخزن را متوجه شدیم، لازم است بتوانیم یک مخزن را ایجاد و سپس با آن پروژهٔ خود را مدیریت کنیم. با استفاده از دستور زیر می‌توان یک مخزن جدید ساخت:

```bash
git init [repo-name]
```

اگر با ترمینال (یا command line ویندوز) کار می‌کنید، ابتدا باید اطمینان حاصل کنید که در مسیر درستی برای ساخت مخزن قرار دارید. برای اینکار از دستور `pwd` (در ترمینال لینوکس) یا `dir` در command line ویندوز استفاده می‌کنیم:

```bash
cw@testing:~$ pwd
/home/cw/
```

دستور `pwd` (که یک دستور لینوکسی است) به ما اعلام می‌کند که مسیر فعلی چیست (**با این دستور در مبحث لینوکس بیشتر آشنا می‌شویم**). خروجی دستور بالا در یک ماشین لینوکسی معنا پیدا می‌کند. در یک ماشین ویندوزی (و با استفاده از Git Bash)، خروجی به این شکل خواهد بود:

```bash
cw@testing: MINGW64 ~
$ pwd
/c/Users/cw
```

در ادامه مثال، یک مخزن گیت درون پوشه‌ای با نام `project` می‌سازیم: 

```bash
cw$testing:~$ git init project
Initialized empty Git repository in /home/cw/project/.git/
```

سپس بررسی می‌کنیم که در پوشه `project` که ساخته شده چه چیزهایی وجود دارد:

```bash
cw@testing:~$ ls -a project
.  ..  .git
```

سه پوشه در پوشه `project` وجود دارد؛ `.`، `..` و `.git`. با دو پوشه اول در مبحث لینوکس آشنا خواهید شد. همینقدر بدانید که پوشه `.git` محلی است که مخزن پروژه `project` در آن قرار دارد.

می‌توانید محتویات پوشه مخزن را نیز ببینید (در این درس از بررسی آنها چشم‌پوشی می‌کنیم):

```bash
cw@testing:~$ ls -a project/.git
branches  config  description  HEAD  hooks  info  objects  refs
```

در صورتی که ورودی دستور `git init` خالی باشد، مخزن در پوشه ی فعلی (که در آن قرار داریم) ذخیره می‌شود. به عبارتی، در مثال قبل می‌توانستیم ابتدا پوشه `project` را ایجاد کنیم و سپس یک مخزن درون آن ایجاد کنیم.

<div class="meta warning">
<p>
پوشه ی .git حاوی کلیه ی اطلاعات مهم پروژه توسط گیت است و نباید هیچ وقت آن را حذف کنید . در صورت حذف آن، کلیه ی سوابق پروژه و تغییرات آن از بین می‌رود.
</p>
</div>
------




## ثبت مشخصات کاربر 

پس از نصب گیت و قبل از هر کاری، می‌بایست اطلاعات خود را که شامل یک ایمیل و یک نام کاربری است در تنظیمات مخزن ثبت کنید: 

```bash
git config --global user.email "youremail"
git config --global user.name "yourusername"
```

با اینکار، شما به صورت سراسری ایمیل و نام کاربری‌تان را برای هر پروژه‌ای که تحت گیت باشد، تنظیم می‌کنید. اگر مایل به تنظیم سراسری این موارد نیستید یا می‌خواهید این تنظیمات را برای هر پروژه‌ به صورت مجزا انتخاب کنید، دستور بالا را بدون سوییچ `--global` و در پوشه پروژه مورد نظر، اجرا کنید. برای مثال، دستورات بالا را به این شکل وارد می‌کنیم:

```bash
cw@testing:~/project$ git config user.email "testing@cw.com"
cw@testing:~/project$ git config user.name "tester"
```

<div class="meta notice">
<p>
ایمیل و نام کاربری‌ای که در تنظیمات گیت وارد می‌کنید، می‌تواند هر چیزی باشد‌(حتی جعلی). با این حال، توصیه می‌شود تا انتخاب‌تان به گونه‌ای باشد که برای سایر کاربران پروژه قابل شناسایی باشید.
</p>
</div>


## ایجاد و ثبت تغییرات 

پس از مقداردهی اولیه مخزن، در پوشه ی مربوط به پروژه تغییرات خود را اعمال کنید. برای افزودن فایل (یا فایل‌های) خود به Staging Area از دستور زیر استفاده می‌کنیم:

```bash
git add file [file1] [file2] ... 
```

برای مثال، فایل `hello` را می‌سازیم و به پروژه اضافه می‌کنیم: (با دستور echo در مبحث آموزش لینوکس بیشتر آشنا می‌شوید، همانقدر بدانید که در خط اول دستور پایین فایل `hello` شامل محتوای متنی `Hello World` ایجاد شده‌است)

```bash
cw@testing:~/project$ echo 'Hello World!' > hello
cw@testing:~/project$ git add hello
```

برای ثبت حالت فعلی پروژه (ایجاد لحظه‌نگار جدید)، از دستور زیر استفاده می‌کنیم:

```bash
git commit -m [your-commit-message]
```

در ادامه مثال قبلی، ثبت کامیت را به صورت زیر انجام می‌دهیم:

```bash
cw@testing:~/project$ git commit -m "added file 'hello'"
[master (root-commit) 28de2e5] added file 'hello'
 1 file changed, 1 insertion(+)
 create mode 100644 hello
```

میتوان به جای اضافه کردن تک به تک فایل‌ها، از کاراکتر نقطه `.` استفاده کنیم. با اینکار، تمامی فایل‌هایی که یا در مسیر فعلی قرار دارند، یا محل قرارگیری آنها جزو زیرمجموعه‌های مسیر فعلی است، به Staging Area اضافه می‌شوند:

```bash
git add . 
```

برای هر کامیت **باید** یک پیام وارد شود. این پیام شامل یک عبارت توضیحی در مورد تغییراتی است که در فایل ها ایجاد شده است.

<div class="meta notice">
<p>
همواره سعی کنید تا پیام کامیت را به گونه‌ای انتخاب کنید که هم کوتاه باشد، هم معرف تغییراتی باشد که این پیام را روی آن قرار می دهید.
</p>
</div>


------



## گزارش تغییرات

با استفاده از دستور زیر می‌توان اطلاعات کلی کامیت‌هایی که اخیرا در پروژه اعمال شده است را مشاهده کنیم:

```bash
git log 
```

اجرای این دستور منجر به این خروجی خواهد شد:

```bash
cw@testing:~/project$ git log
commit 28de2e5cf7fc12a499484165b71fbbe8940799bc (HEAD -> master)
Author: tester <tester@cw.com>
Date: Mon Sep 27 18:44:01 2021 +0330
	
	added file `hello`
```

<div class="meta notice">
<p>
هر کامیت، مقدار منحصر به فردی دارد که با عنوان
commit hash
یا هشِ کامیت شناخته می‌شود. در خروجی دستور
<code>git log</code>
مقدار نوشته شده روبروی عبارت
<code>commit</code>
همان هش کامیت است. هر زمان که استفاده از هش کامیت نیاز شد، می‌توانید تنها ۷ کاراکتر اول آن را بنویسید.
</p>
</div>


------



## گزارش وضعیت 

با استفاده از دستور زیر می‌توان اطلاعات زیادی را در مورد مخزن دریافت کرد.

```bash
git status
```

اطلاعات قابل نمایش توسط این دستور عبارتند از:

- شاخه کنونی 
- وضعیت تازگی اطلاعات نسبت به سرور 
- فایل‌های تغییر یافته (Modified)  ولی نشان نشده (‌Unstaged)
- فایل‌های تغییر یافته و آمادهٔ ثبت (Staged)
- فایل‌های جدیدا اضافه شده و آماده ثبت (Staged)
- فایل‌های موجود ولی خارج از رصد (Untracked)

پس از اجرای دستور بالا خروجی زیر ظاهر می‌شود:

```bash
cw@testing:~/project$ git status
On branch master
nothing to commit, working tree clean
```

طبیعی است که چیزی برای کامیت شدن وجود نداشته باشد (چون تغییر جدیدی رخ نداده است). حال یک فایل جدید ایجاد می‌کنیم تا وضعیت را مجددا بسنجیم:

```bash
cw@testing:~/project$ echo "Hello Universe!" > universe
cw@testing:~/proejct$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be commited)
        universe


nothing added to commit but untracked files present (use "git add" to track)
```

با دستورات بالا، فایل `universe` را ایجاد و دستور `git status` را مجددا اجرا کردیم. همانطور که مشاهده می‌شود، فایل تازه ایجاد شدهٔ `universe` توسط گیت شناسایی شده است، ولی هنوز تغییرات آن رصد نمی‌شود. برای معرفی این فایل به گیت از دستور `git add` استفاده کرده و سپس وضعیت را دوباره می‌سنجیم:

```bash
cw@testing:~/project$ git add universe
cw@testing:~/project$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   universe
```

مشاهده می‌شود که پس از اضافه شدن، وضعیت فایل `universe` تغییر کرد و به حالت Staged تغییر یافت. حال محتویات فایل `hello` (که قبلا ساخته شده است) را تغییر می‌دهیم و وضعیت را دوباره بررسی می‌کنیم:

```bash
cw@testing:~/project$ echo "Hello again" >> hello
cw@testing:~/project$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   universe

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:    hello
```

همانطور که مشاهده می‌شود فایل `hello` آماده ی کامیت شدن نیست (در حالت modified قرار دارد). برای تغییر حالت فایل‌های Modified به Staged، می‌بایست از سوییچ `-a` در دستور کامیت استفاده کرد:

```bash
cw@testing:~/project$ git commit -am "added file 'universe'"
[master 524757a] added file 'universe'
 2 files changed, 2 insertions(+)
 create mode 100644 universe
cw@testing:~/project$ git status
On branch master
nothing to commit, working tree clean
cw@testing:~/project$ git log
commit 523757a046e5f44aeed6131e516ffb37e694dcfa
Author: tester <tester@cw.com>
Date: Mon Sep 27 20:03:41 2021 +0330

    added file 'universe'

commit 28de2e5cf7fc12a499484165b71fbbe8940799bc
Author: tester <tester@cw.com>
Date: Mon Sep 27 18:44:01 2021 +0330
    
    added file 'hello'
```

<div class="meta notice">
<p>
وقتی از دو سوییچ به صورت همزمان در دستور استفاده می‌کنیم (اینجا یعنی سوییچ‌های
<code>-a</code> و
<code>-m</code>
)
می‌توان آنها را چسبیده بهم نوشت. در این صورت، تنها یک کاراکتر
<code>-</code>
نوشته می‌شود.
</p>
</div>

در صورتی که از سوییچ ‍`-a` استفاده نکنیم، فایل `hello` همچنان در حالت Modified خواهد ماند:

```bash
cw@testing:~/project$ git commit -m "added file 'universe'"
[master 771d323] added file 'universe'
 1 file changed, 1 inserstion(+)
 create mode 100644 universe
cw@testing:~/project$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello

no changes added to commit (use "git add" and/or "git commit -a")
```

یک راه دیگر آن است که پس از تغییر فایل `hello` مجددا آن را با دستور `git add` به حالت Staged ببریم:

```bash
git add hello
```

------



## ساخت شاخه

هنگامی که به تازگی یک مخزن ایجاد می‌کنیم، به صورت پیش‌فرض یک شاخه ی `master` ساخته می‌شود که نقش شاخه اصلی مخزن مذکور را بازی می‌کند و هر کامیتی که انجام دهیم روی این شاخه انجام می‌شود. یکی از مزایای وجود شاخه‌ها در سیستم کنترل نسخهٔ گیت آن است که می‌توان به تعداد توسعه‌دهندگانی که در تیم حضور دارند شاخه‌های اختصاصی ساخته و در آن واحد تمامی اعضای تیم بتوانند اقدام به پیشبرد پروژه کنند.

<div class="meta info">
<p>
در توسعه ی پروژه، فقط باید کدهایی روی شاخهٔ اصلی قرار گیرد که کاملا پایدار و بدون مشکل هستند. با این تفاسیر منطقی به نظر میرسد که شاخهٔ <code>master</code> به عنوان شاخهٔ آزمون و خطا استفاده نشود و هنگامی که یکی از اعضای تیم قصد توسعهٔ نرم افزار را داشت شاخهٔ جدایی را ایجاد کرده و روی آن ادامه دهد تا هنگامی که به پایداری اشاره شده برسد.
</p>
</div>



<p align="center">
  <img src="../imgs/git/37.jpg">
</p>

 *تصویر ۱۹ - شاخه اصلی پروژه به همراه دو شاخه فرعی*



همان‌طور که در تصویر فوق ملاحظه می‌شود، خط افقی که در سراسر نمودار مشاهده می‌شود به عنوان شاخه اصلی یا `master` است. فرض می‌کنیم توسط توسعه‌دهندهٔ اصلی پروژه، کامیت‌هایی تحت عناوین C1 و C2 انجام شده است. سپس یک شاخه از شاخهٔ اصلی جدا شده و نامی دلخواه همچون `Branch1` برای آن در نظر گرفته‌ایم (که فرضاً توسط یکی از اعضای تیم توسعه داده می‌شود) به طوری که وی سه کامیت داخل این شاخه انجام داده است. به صورت موازی،‌ برای یکی دیگر از اعضای تیم شاخه‌ای به نام `Branch2` ساخته شده و او نیز یک کامیت در این شاخه انجام داده است. در نهایت، دولوپر اصلی این پروژه کلیهٔ تغییرات اِعمال‌شده در دو شاخه فوق را با شاخه اصلی ادغام کرده و مجموع این تغییرات را تحت عنوان C7 در شاخه اصلی کامیت کرده است.

در مثال خودمان، برای آنکه لیستی از شاخه‌های پروژه را مشاهده کنیم دستور زیر را اجرا می‌کنیم:‌

```bash
cw@testing:~/project$ git branch
* master
```

این دستور لیستی از کلیه ی شاخه‌ها را نمایش می‌دهد و همانطور که گفته شد، شاخهٔ `master` به صورت شاخه انتخابی پیش‌فرض نمایش داده شده‌است. علامت `*` تایید می‌کند که در حال حاضر، روی این شاخه هستیم.

فرض کنید که می‌خواهیم شاخهٔ دیگری از شاخهٔ اصلی انشعاب بگیریم تا وظایف خود را روی آن شاخه ادامه دهیم. به شکل زیر عمل کرده و شاخه ی `Branch1` را ایجاد می‌کنیم:

```bash
cw@testing:~/project$ git branch Branch1
```

پس از ایجاد شاخهٔ مورد نظر، یک بار دیگر لیست شاخه‌ها را نمایش می‌دهیم:

```bash
cw@testing:~/project$ git branch
* master
  Branch1
```

------



## جابجایی میان شاخه‌ها و کامیت‌ها

برای رفتن به شاخه‌ای غیر از شاخه فعلی از دستور زیر استفاده می‌کنیم:

```bash
git checkout <branch-name>
```

در مثال قبل، برای رفتن به شاخه `Branch1` به این صورت عمل می‌کنیم:

```bash
cw@testing:~/project$ git checkout Branch1 
Switched to branch 'Branch1'
```

با بررسی مجدد لیست شاخه‌ها، می‌بینیم که علامت `*` نیز روبروی نام `Branch1` قرار گرفته و جابجایی تایید شده است:

```bash
cw@testing:~/project$ git branch
  master
* Branch1
```

از دستور `git checkout` همچنین برای ایجاد یک شاخه و پریدن روی آن در قالب یک دستور واحد نیز استفاده می‌شود:

```bash
git checkout -b <branch-name>
```

در واقع دستور بالا، خلاصه دو دستور پایین است:

```bash
git branch <branch-name>
git checkout <branch-name>
```

برای آنکه در عمل هم متوجه این موضوع شویم، در ادامه مثال قبل یک فایل متنی ایجاد می‌کنیم؛ سپس آن را کامیت می‌کنیم تا ببینیم تغییرات در کدام شاخه اعمال می‌شود:

```bash
cw@testing:~/project$ git add new.txt
cw@testing:~/project$ git commit -m "new file added"
[branch1 b276cac] new file added
 1 file changed, 3 insertions(+)
 create mode 100644 new.txt
```

سپس گزارش تغییرات شاخه را با دستور `git log` چک می‌کنیم:

```bash
cw@testing:~/project$ git log --oneline
b276cac (HEAD -> Branch1) new file added
...
```

همانطور که می‌بینیم در پیامی که برای کامیت آمده است، مشاهده می‌شود که تغییرات روی `Branch1` اعمال شده است و نه شاخه `master`. سوییچ `--oneline` برای این استفاده شده‌است که تنها موارد کلی مثل پیام کامیت و ۷ کاراکتر اول  `Commit hash` نمایش داده‌شود و از نمایش غیرضروری جزئیات دیگر خودداری شود.

با جابجایی میان شاخه‌ها، به صورت پیش‌فرض به آخرین کامیت شاخه مقصد می‌رویم. تصویر زیر بیانگر این موضوع است (بنابراین محتوای فایل‌های موجود در پوشه‌ٔ پروژه تغییر می‌کند)

<p align="center">
  <img src="../imgs/git/44.jpg">
</p>



یک نکته مهم؛ که از آنجایی که جابجایی بین کامیت‌های دو شاخه انجام می‌شود، بر اساس اختلافات میان این دو کامیت، ممکن است پس از اجرای دستور فایل‌ها و محتوای آنها تغییراتی داشته باشد. با برگشت به شاخه (و کامیت) قبلی، فایل‌ها و محتوایشان به حالت سابق باز خواهند گشت. برای فهم بهتر این موضوع، به شاخه ی `master` رجوع می‌کنیم تا وضعیت فایل `new.txt` در این شاخه را بررسی کنیم: 

```bash
cw@testing:~/project$ git checkout master 
Switched to branch 'master'
```

اکنون اگر به محتویات داخل پوشه نگاهی بیندازیم،‌ خواهیم دید که فایل `new.txt` حذف شده است.

همانطور که بالاتر گفته شد، با جابجایی میان شاخه‌ها، به صورت پیش‌فرض به آخرین کامیت شاخه مقصد می‌رویم. با این حال، می‌توان در هنگام رفتن به شاخه مقصد، کامیت مورد نظر را نیز مشخص کرد. برای اینکار، پس از نام شاخه در دستور `checkout`، مقدار هش کامیت مورد نظر را می‌نویسیم:

```bash
git checkout [branch-name] [commit-hash]
```

اگر هدف جابجایی میان کامیت‌های شاخه فعلی باشد، می‌توان از نوشتن نام شاخه در دستور بالا صرف نظر کرد. به عبارت دیگر، دستور بالا را می‌توانیم به این صورت بنویسیم:

```bash
git checkout [commit-hash]
```

همچنین، برای رفتن به n (که n یک عدد صحیح بزرگتر از صفر است) کامیت عقب‌تر از کامیت نهایی می‌توانیم بدین شکل از دستور استفاده کنیم (اگر شاخه فعلی مد نظر است، نام شاخه را خالی بگذارید):

```bash
git checkout [branch-name] HEAD~n
```



<div class="meta warning">
<p>
اگر در شاخه فعلی تغییراتی انجام داده باشید ولی آنها را کامیت نکرده باشید، اجازه جابجایی به شما داده نخواهد شد. لذا، ابتدا لازم است تا تغییرات در شاخه فعلی را به سرانجام برسانید.
</p>
</div>
ممکن است شما قصد انجام `commit` تغییراتی را که داده‌اید نداشته باشید و بخواهید بدون انجام یک کامیت روی شاخه‌ی فعلی به شاخه‌ی دیگر پرش انجام‌دهید. برای ذخیره‌سازی موقت تغییراتی که داده‌اید در گیت می‌توانید از دستور Stash استفاده کنید. برای این کار از دستور زیر استفاده می‌کنیم : 

```bash
git stash 
```

با استفاده از دستور `stash`  فایل‌هایی که به صورت محلی تغییر داده شده‌بودند به صورت موقت ذخیره‌سازی می‌شوند بدون آنکه نیازی به کامیت‌شدن داشته باشند.

با استفاده از دستور بالا به راحتی می‌توانید شاخه‌ی خود را تغییر داده و وظایف شاخه‌ی دیگر را انجام دهید. پس از بازگشت از شاخه‌‌ای که به آن مهاجرت کرده‌بودید و برای بازگرداندن تغییراتی که `Stash` شده بودند از دستور زیر استفاده کنید: 

```bash
git stash pop
```

با استفاده از دستورات بالا توانستیم بدون آن‌که نیازی به کامیت‌شدن فایل‌های تغییر داده‌شده باشد شاخه‌ی خود را عوض کنیم و پس از بازگشت از آن شاخه بتوانیم تغییراتی که کامیت نشده‌بودند را بازگردانی کنیم.

------




## ادغام شاخه‌ها

با استفاده از دستور `git merge` می‌توان دو شاخه‌ ی موجود را با هم ادغام کرد. برای مثال فرض کنید که حسین ابتدا یک شاخه‌ برای خود از شاخه‌ ی اصلی ایجاد کرده و آن را توسعه داده است و حالا قصد دارد تا تمامی تغییراتی که روی شاخه‌ ی خود داده‌ است را روی شاخه‌ ی اصلی نیز اعمال کند.

![1](../imgs/git/46.jpg)


در تصویر بالا، فرض کنید شاخه‌ ی زرد توسط حسین از شاخه‌ ی اصلی جدا شده‌ است و توسعه داده‌ شده و حال قصد دارد این دو شاخه را با هم ادغام کند تا به شکل سمت راست تبدیل شود. برای این کار ابتدا روی شاخه‌ ی `feature` می‌رویم:

```bash
git checkout feature 
```

سپس با استفاده از دستور زیر شاخه‌ی `feature` را با شاخه‌ی `master` ادغام می‌کنیم.

```bash
git merge master
```

دو عمل بالا را می‌توان به صورت یک دستور نیز انجام داد:‌

```bash
git merge master feature
```

## حذف شاخه

با استفاده از سوییچ `-d` میتوان یک شاخه را حذف کرد. در ادامه مثال قبل، سعی می‌کنیم تا شاخه ای که ایجاد کرده‌ایم، حذف کنیم:

```bash
cw@testing:~/project$ git branch -d branch1
error: The branch 'branch1' is not fully merged.
If you are sure you want to delete it, run 'git branch -D branch1'.
```

همانطور که مشاهده می‌کنید شاخه ی `branch1` حذف نشد و گیت هشدار می‌دهد که تغییراتی که در آن شاخه اعمال شده است هنوز با شاخه ی `master` ادغام یا merge نشده است.

<div class="meta warning">
<p>
اگر از آپشن D (به صورت حروف بزرگ) در دستور استفاده کنیم بدون توجه به ادغام این دو شاخه آن را حذف میکند.
</p>
</div>



بعد از حذف، اگر نگاهی دوباره به شاخه ها بیندازیم، می‌بینیم که شاخه ی `branch1` حذف شده است:‌

```bash
cw@testing:~/project$ git branch
* master
```

<div class="meta info">
<p>
مفهوم شاخه‌ها در گیت را به نوعی می‌توان به عنوان یکی از کلیدی‌ترین خصیصه‌های این سیستم کنترل نسخه تلقی کرد؛ چرا که اساساً این امکان در اختیار تیم‌های مهندسی قرار می‌گیرد تا بتوانند به هر تعداد که بخواهند شاخهٔ جدید ایجاد کرده و افراد متعددی به صورت همزمان و موازی روی پروژه کار کنند.
</p>
</div>
------



## گیتهاب 

پیش از این اشاره کردیم که دو نوع مخزن داریم؛ محلی و از راه دور (ریموت). [گیتهاب](https://github.com/) (Github) یک مخزن تحت وب است که به شما اجازه می‌دهد تا پروژه‌های خود را به صورت ریموت در اختیار دیگران قرار دهید. در ادامه ی این موضوع، فرض کنید که دو نفر بر روی یک پروژه ی مشترک کار می‌کنند که یکی در یک شهر و دیگری در شهری دیگر زندگی می‌کند. گیتهاب این امکان را فراهم می‌کند که این دو نفر، مخازن خود را با یکدیگر اشتراک بگذارند.

برای این که یک مخزن ریموت در گیتهاب درست کنید باید ابتدا در این وبسایت ثبت نام کنید و سپس با استفاده دکمه ی سمت راست و کنار تصویر پروفایل `new repository` را کلیک کنید. 

<p align="center">
  <img src="../imgs/git/38.jpg">
</p>
*تصویر ۲۰ - منوی اعمال مرتبط با مخزن در گیتهاب*

پس از کلیک بر روی این دکمه صفحه‌ی زیر باز می‌شود که اطلاعات مربوط به مخزن یعنی نام پروژه و دیگر ویژگی‌ها از جمله عمومی و یا خصوصی بودن آن را باید مشخص کنید و سپس مخزن را ایجاد کنید.

![1](../imgs/git/39.jpg)

*تصویر ۲۱ - ساخت مخزن جدید در گیتهاب*



پس از ایجاد مخزن برای این که فایل های خود را روی مخزن قرار دهیم تا دیگران بتوانند به آن دسترسی داشته باشند، باید ابتدا آدرس مخزن ریموت خود را به مخزن محلی خود اضافه کنیم تا مخزن محلی به مخزن ریموت متصل شود. برای این کار از دستور زیر استفاده می‌کنیم:

```bash
git remote add origin git@github.com:ROF13ThFloor/TestRepo.git
```

پس از اضافه شدن مخزن ریموت گیتهاب، باید کدهای کامیت شده ی خود را به گیتهاب اضافه کنیم. برای این کار از دستور `push` استفاده می‌کنیم:

```bash
git push -u origin main
```

------



## دریافت تغییرات از مخزن ریموت

همانطور که گفته شد Staging Area محدوده‌ای است که فایل‌های موجود در این ناحیه تحت نظاره گیت قرار گرفته‌اند و گیت تغییرات آنها را بررسی می‌کند. همچنین گفته‌ شد که با استفاده از دستور ‌`git add` می‌توان یک فایل را به Staging Area اضافه کرد. پس از آن و با استفاده از دستور `git commit` و تعیین پیام آن، تغییرات در محیطی تحت عنوان Local Git Repository یا «مخزن محلی گیت» ذخیره می‌شود. در این قسمت تمامی تغییرات بر‌ روی نسخه‌ ی محلی (=ماشین‌ شما) ذخیره شده‌ است و نسخه‌‌ی ریموت ‌تغییری نکرده‌‌است. همچنین در قسمت قبل گفتیم که می‌توانیم با استفاده از دستور push تغییرات نسخه‌‌ی محلی را روی نسخه‌‌ی ریموت هم اعمال کنیم. 

برای درک بهتر روند اضافه‌شدن به Staging Area تا اضافه‌ شدن به مخزن ریموت، تصویر زیر را مشاهده کنید.

![1](../imgs/git/40.jpg)

*تصویر - مراحل ثبت تغییرات و ارسال آن به مخزن از راه دور*



سناریوی زیر را در نظر می‌گیریم: 

فرض کنید علی و محمد دو نسخه‌ی یکسان از یک برنامه یا فایل را در کامپیوتر خود در اختیار دارند. علی مدتی روی قسمتی از کد کار می‌کند و به محمد می‌گوید که پس از تکمیل این بخش از کد آن را در گیتهاب قرار می‌دهد تا محمد بتواند با دریافت آن ادامه‌ ی کدی که علی نوشته‌است را توسعه دهد. پس از تغییراتی که علی داده‌ است آن را با دستور push روی گیت‌هاب قرار می‌دهد و به محمد خبر می‌دهد. سوالی که پیش می‌آید این‌ است که محمد چگونه باید تغییراتی که علی داده‌ است را دریافت کند؟ نسخه‌ای که محمد در اختیار دارد نسخه‌ ی پیش از توسعه ی علی است. 

محمد برای دریافت تغییرات باید از دستور زیر استفاده کند:‌

```bash
git fetch 
```

پس از اجرای دستور بالا در کامپیوتر محمد، می‌توان تغییراتی که علی داده است را مشاهده کرد، لازم به ذکر است که با اجرای دستور بالا کدی که روی کامپیوتر محمد است تغییری نمی‌کند و ما فقط میتوانیم تغییراتی که علی داده‌ است را مشاهده کنیم (تغییراتی که علی داده‌ است را دریافت می‌کند ولی آن را در Working tree اعمال نمی‌کند). برای این که تغییراتی که علی داده‌ است را روی Working tree محمد هم داشته باشیم‌ (کد محمد دچار تغییر شود) از دستور زیر استفاده می‌کنیم.

```bash
git pull origin master
```

در این دستور گفته می‌شود که تمامی تغییراتی که روی شاخه `master` آدرس ریموت یعنی `origin` (که در قسمت قبل آن را اضافه کردیم) داشتیم را روی شاخه‌ی `master` مخزن محلی نیز اعمال شود.

در واقع دستور `pull` علاوه بر این‌ که تغییرات را دریافت می‌کند (`fetch`) آن‌ها را در Working tree اعمال نیز می‌کند. اگر بخواهیم باقی شاخه‌های موجود نیز به روزرسانی شوند از دستور زیر استفاده می‌کنیم:

```bash
git pull
```

بدین ترتیب محمد تمام تغییراتی که علی داده‌بود را دریافت می‌کند و می‌تواند روی آن ادامه‌ دهد. این تغییرات شامل اضافه‌شدن شاخه‌ها نیز می‌باشد.


### دریافت یک پروژه از مخزن ریموت
فرض کنید پروژه‌ای را در گیتهاب مشا‌هده کرده‌اید که قصد دریافت آن‌ را دارید (یعنی این پروژه اکنون روی کامپیوتر شما نیست). برای دریافت پروژه، به صفحه‌ی مرتبط با آن در گیتهاب مراجعه کنید و آدرس مخزن را (همانند تصویر زیر) دریافت کنید. 

![1](../imgs/git/41.jpg)



همانطور که در تصویر می‌بینید روی دکمه‌ی `code` کلیک کنید و آدرس موجود در بخش `https` را کپی کنید. سپس در ترمینال با استفاده از دستور زیر پروژه را دریافت کنید (لینک دریافت مخزن برای کاربر و پروژه‌های دیگر، متفاوت خواهد بود).

```bash
git clone <repo-link>
```

پس از اجرای دستور بالا، گیت از شما نام‌ کاربری و رمز عبور گیتهاب را درخواست می‌کند که پس از وارد کردن آنها پروژه‌ی مذکور در پوشه‌ی فعلی دریافت می‌شود.

<p align="center">
  <img src="../imgs/git/42.jpg">
</p>


همانطور که مشاهده می‌شود پروژه‌ی `CreateRaid05Script` در پوشه‌ی فعلی دریافت‌ شد.

------



## بازنشانی تغییرات

این دستور، یک دستور چندمنظوره برای لغو تمامی تغییراتی است که اعمال کرده‌ایم. فرض کنید که در بازه‌ای شما تغییراتی را در برنامه‌ی خود اعمال کرده‌اید که اشتباه‌ بوده‌ است و الان متوجه اشتباه‌‌ بودن آن شده‌اید. اگر قصد دارید تغییراتی که اعمال کرده‌اید را پاک کنید و به  آخرین کامیتی که که انجام داده‌اید بازگردید، از دستور زیر استفاده کنید.  

```bash
git reset [commit-hash]
```

دستور `git reset` می‌تواند سه نوع سوییچ به عنوان ورودی دریافت کند: 

### سوییچ --hard 
این سوییچ باعث می‌شود که تغییراتی که Staged هستند و یا هنوز استیج‌نشده باقی‌ماندند لغو می‌شوند. 

```bash
git reset --hard HEAD
```

به جای HEAD می‌توان از هر هش کامیت معتبری استفاده کرد. برای مثال، با اجرای دستور زیر تمامی کامیت‌های بعد از هش کامیت وارد شده از دست خواهند رفت:

```bash
git reset --hard [commit-hash]
```

علاوه بر این تمامی فایل‌هایی که Staged هستند و یا هنوز Staged نشده‌اند نیز حذف می‌شوند و تاریخچه‌ی کامیت‌ها به کامیت مورد نظر تغییر می‌کند.

### سوییچ --mixed

این سوییچ تمام فایل‌ها را در حالت فعلی نگه‌داری می‌کند ولی آن‌ها را از حالت Staged خارج ‌می‌کند. 

```bash
git reset --mixed [commit-hash]
```

برای درک بهتر این قسمت فرض کنید شاخه‌ی `master` شامل سه کامیت A,B,C باشد که آخرین کامیت C می‌باشد. در صورتی که از دستور بالا استفاده کنیم تمامی تغییراتی که داده‌ایم و آن‌ها را پیش از این Stage کرده‌ایم از حالت Stage خارج می‌شوند. در این حالت همچنان تغییرات قابل مشاهده است اما Stage شده نیستند.

### سوییچ --soft 
این سوییچ همچنان تغییرات را نگهداری می‌کند و حتی فایل‌هایی که Stage شده‌اند را هم در حالت Stage نگه‌داری می‌کند. برای درک بهتر این سوییچ فرض کنید سه کامیت A-B-C وجود دارد و ما از دستور زیر استفاده میکنیم . 

```bash
git reset --soft b
```

پس از اجرای دستور بالا `HEAD` (اشاره‌گر به آخرین کامیت) به کامیت `b` اشاره می‌کند  و علاوه بر این تمامی تغییراتی که در کامیت `C` بوده‌است به صورت `Stage` شده باقی خواهد‌ماند. (در حالت `mixed` این اتفاق رخ نمی‌داد و کلیه‌ی فایل‌هایی که در کامیت `C` هستند از حالت Staged خارج می‌شوند)

قالب کلی دستور `reset` با سوییچ `--soft` به شکل زیر است.

```bash
git reset --soft [commit-hash]
```

برای درک بهتر تفاوت این سه سوییچ می‌توانید از تصویر زیر استفاده‌ کنید.

![1](../imgs/git/43.jpg)

------



## حذف فایل

برای حذف یک فایل از پوشه‌ی پروژه از دستور زیر استفاده می‌کنیم:

```bash
git rm [file-name]
```

## تغییر نام فایل

فرض کنید در پوشه‌ی کاری خود قصد دارید نام یک فایل را تغییر دهید با استفاده از دستور زیر می‌توان نام فایل مورد نظر را تغییر داد:

```bash
git mv [old-name] [new-name]
```

## معرفی وبسایت Katacoda 
وبسایت کاتاکودا یک محیط تعاملی برای تمرین ابزار‌های مهندسی کامپیوتر است. یادگیری گیت نیاز به تمرین و تفکر عمیق دارد. برای استفاده از این [وبسایت به آدرس آن مراجعه کنید](https://www.katacoda.com/). در این وبسایت و در قسمت [یادگیری گیت](https://www.katacoda.com/courses/git)  می‌توان سناریو‌های متفاوتی را مشاهده کرد که پس از انجام آن‌ها وبسایت، آن را بررسی و صحت درستی آن را به شما اعلام می‌کند.

## کلام پایانی

یادتان باشد گیت یکی از مهمترین ابزار‌های یک مهندس کامپیوتر است و یادگیری آن بر هر مهندسی واجب !‌ :) 



![1](../imgs/git/47.jpg)
